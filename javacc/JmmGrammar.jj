PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;
TOKENS_ARE_NODES=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :

    // Keywords
    < CLASS : "class" > |
    < PUBLIC : "public" > |
    < STATIC : "static" > |
    < IMPORT : "import" > |
    < MAIN : "main" > |
    < VOID : "void" > |
    < EXTENDS : "extends" > |
    < LENGTH : "length"> |
    < NEW : "new" > |
    < THIS : "this" > |
    < RETURN : "return" > |


    // Operations
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGN : "=" > |
	< LESS_THAN : "<" > |
	< LOGIC_AND : "&&" > |
	< OPEN_PAREN : "(" > |
    < BANG : "!" > |

	// Literals and Factors
    < TRUE : "true" > |
    < FALSE: "false" > |

	// Delimiters
	< CLOSE_PAREN : ")" > |
	< OPEN_SQUARE_BRACES : "[" > |
	< CLOSE_SQUARE_BRACES : "]" > |
	< OPEN_CURLY_BRACES : "{" > |
	< CLOSE_CURLY_BRACES : "}" > |
	< SEMICOLON : ";" > |
    < INLINE_COMMENT: "//" > |
    < COMMA : ","> |
    < DOT : "." > |
    // < LINE_COMMENT: "/*" > (!"*/" .)* "*/" >;

	// Logic and Control
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |


    // Types
    < BOOLEAN : "boolean" >  |
    < STRING : "String" > |
    < INT : "int" > |

    // Regex
    < IDENTIFIER : ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "_", "0"-"9"])* > |
    < INTEGER_LITERAL : (["0" - "9"])+ >
;

// TODO: Correct this implementation
//SPECIAL_TOKEN: 
//	<INLINE_COMMENT> (~["\n","\r"])* ("\n"|"\r"|"\r\n") 
//; 


Start : ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration : (< IMPORT > < IDENTIFIER > (< DOT > < IDENTIFIER >)* < SEMICOLON >)* ;

ClassDeclaration :
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)?
    <OPEN_CURLY_BRACES>
        (VarDeclaration)*
        (MethodDeclaration)*
    <CLOSE_CURLY_BRACES> ;

VarDeclaration : Type <IDENTIFIER> <SEMICOLON> ;
Type :  SCAN 2 (<STRING> | <BOOLEAN> | <IDENTIFIER> | (<INT> (<OPEN_SQUARE_BRACES> <CLOSE_SQUARE_BRACES>)?)) ;

// MethodDeclaration

MethodDeclaration : <PUBLIC> (MainDeclaration | ClassMethodDeclaration) ;

MainDeclaration :
    <STATIC> <VOID> <MAIN>
    <OPEN_PAREN> <STRING> <OPEN_SQUARE_BRACES> <CLOSE_SQUARE_BRACES>
    <IDENTIFIER>
    <CLOSE_PAREN> <OPEN_CURLY_BRACES> MethodBody <CLOSE_CURLY_BRACES> ;

ClassMethodDeclaration :
    Type <IDENTIFIER> <OPEN_PAREN>
    (ParameterDeclaration ( < COMMA > ParameterDeclaration)*)? < CLOSE_PAREN > < OPEN_CURLY_BRACES >
    MethodBody < RETURN > Expression <SEMICOLON > < CLOSE_CURLY_BRACES > ;

MethodBody: (VarDeclaration)* (Statement)* ;

ParameterDeclaration : Type <IDENTIFIER> ;

MethodCall: <IDENTIFIER> <OPEN_PAREN> ParametersExpression <CLOSE_PAREN> ;

ParametersExpression: AndExpression (<COMMA> AndExpression)* ;



// Logic and Control

Statement: SCAN 2 (
    <OPEN_CURLY_BRACES> (Statement)* <CLOSE_CURLY_BRACES>
    | WhileStatement
    | IfStatement
    | <IDENTIFIER> <ASSIGN> Expression <SEMICOLON>
    | <IDENTIFIER> <OPEN_SQUARE_BRACES> Expression <CLOSE_SQUARE_BRACES> <ASSIGN> Expression <SEMICOLON>
    | Expression <SEMICOLON>)
;

IfStatement:
    <IF> <OPEN_PAREN>
        Expression
    <CLOSE_PAREN>
        Statement
    (<ELSE>
        Statement)?;

WhileStatement:
    <WHILE> <OPEN_PAREN>
        AndExpression
    <CLOSE_PAREN>
        Statement;



// Operators

AndExpression :
    LessThanExpression
    (<LOGIC_AND> LessThanExpression)* ;

LessThanExpression:
    (
        AdditiveExpression
        | SubtractionExpression
   )
    ( <LESS_THAN> (AdditiveExpression | SubtractionExpression) )* ;

AdditiveExpression:
    (
        MultiplicationExpression
        | DivisionExpression
    )
    (<PLUS> (MultiplicationExpression | DivisionExpression))* ;

SubtractionExpression:
    (
        MultiplicationExpression
        | DivisionExpression
    )
    (<MINUS> (MultiplicationExpression | DivisionExpression))* ;

MultiplicationExpression:
    ArrayExpression (<TIMES> ArrayExpression)* ;

DivisionExpression:
    ArrayExpression (<DIVIDE> ArrayExpression)* ;

ArrayExpression:
    NegationExpression (ArrayAccessExpression)? ;

NegationExpression:
    ChainedDotExpression | (<BANG> NegationExpression);

ChainedDotExpression:
    Expression (<DOT> (<LENGTH> | MethodCall))* ;

ArrayAccessExpression:
    <OPEN_SQUARE_BRACES>
        AndExpression
    <CLOSE_SQUARE_BRACES> ;



// Expression

Keyword:
    <TRUE>
    | <FALSE>
    | <THIS>;


Expression:  (
    <INTEGER_LITERAL>
    | Keyword
    | <IDENTIFIER>
    | <OPEN_PAREN> AndExpression <CLOSE_PAREN>
    | <NEW> ((<IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN>) | <INT> ArrayExpression));



// Injections for the implementation of JmmNode
// Since this is injected into BaseNode, it affects only non-terminals
INJECT BaseNode :
		import pt.up.fe.comp.jmm.ast.JmmNode;
		import pt.up.fe.comp.jmm.ast.AJmmNode;
		import pt.up.fe.specs.util.SpecsCollections;
		extends AJmmNode
{
    @Override
    public List<JmmNode> getChildren() {

        return SpecsCollections.cast(children(), JmmNode.class);
    }

    @Override
    public void add(JmmNode child, int index) {

        if (child instanceof Node) {

            addChild(index, (Node) child);
        } else {

            throw new RuntimeException("Node " + child + " is not a Node.");
        }

    }
}
