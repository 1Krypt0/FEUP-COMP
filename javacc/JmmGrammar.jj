PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

// [] -> ? (optional - 0 or 1)
// {} -> * (zero or more)


SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGN : "=" > |
	< LESS_THAN : "<" > |
	< LOGIC_AND : "&&" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_SQUARE_BRACES : "[" > |
	< CLOSE_SQUARE_BRACES : "]" > |
	< OPEN_CURLY_BRACES : "{" > |
	< CLOSE_CURLY_BRACES : "}" > |
	< SEMI_COLON : ";" > |

	< INLINE_COMMENT: "//" > | 
	< BANG : "!" > | 

	< IDENTIFIER : ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "_", "0"-"9"])* > | //TODO: complete
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE: "false" > |
    < DOT : "." > |	
	< CLASS : "class" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< IMPORT : "import" > |
	< STRING : "String" > |
	< MAIN : "main" > |
	< VOID : "void" > |
	< EXTENDS : "extends" > |
	< LENGTH : "length"> |
	< COMMA : ","> |
	< NEW : "new" > |
	< THIS : "this" > |
	< INT : "int" > |
	< RETURN : "return" > |
	< BOOLEAN : "boolean" >    
;

//SPECIAL_TOKEN: 
//	<INLINE_COMMENT> (~["\n","\r"])* ("\n"|"\r"|"\r\n") 
//; 


Program : ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration : (< IMPORT > < IDENTIFIER > (< DOT > < IDENTIFIER >)* < SEMI_COLON >)* ;

ClassDeclaration : < CLASS > < IDENTIFIER >  ( < EXTENDS > < IDENTIFIER >)? < OPEN_CURLY_BRACES >
                    (VarDeclaration)* (MethodDeclaration)*
                    < CLOSE_CURLY_BRACES > ;

VarDeclaration : Type <INDENTIFIER> < SEMI_COLON > ;

MethodDeclaration : 
	< PUBLIC > Type < IDENTIFIER > < OPEN_PAREN > (Type < IDENTIFIER > ( < COMMA > Type < IDENTIFIER >)*)? < CLOSE_PAREN > < OPEN_CURLY_BRACES > 
		(VarDeclaration)* (Statement)* < RETURN > Expression <SEMI_COLON > < CLOSE_CURLY_BRACES >
    |
    < PUBLIC > < STATIC > < VOID > < MAIN > <OPEN_PAREN > < STRING > < OPEN_SQUARE_BRACES > < CLOSE_SQUARE_BRACES >
    < IDENTIFIER > < CLOSE_PAREN > < OPEN_CURLY_BRACES > (VarDeclaration)* (Statement)* < CLOSE_CURLY_BRACES >
;


Type : <INT> | <BOOLEAN> | <INT> <OPEN_SQUARE_BRACES> <CLOSE_SQUARE_BRACES> | < IDENTIFIER >;

Statement:
    <OPEN_CURLY_BRACES> (Statement)* <CLOSE_CURLY_BRACES> |
    <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement |
    <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement |
    Expression <SEMI_COLON> |
    <INDENTIFIER> <ASSIGN> Expression <SEMI_COLON> |
    <INDENTIFIER> <OPEN_SQUARE_BRACES> Expression <CL1OSE_SQUARE_BRACES> <ASSIGN> Expression <SEMICOLON>
;



Expression:
    And |
    ArrayAccessExpression <OPEN_SQUARE_BRACES> Expression <CLOSE_SQUARE_BRACES> |
	ArrayCreateExpression | 
    ArrayAccessExpression <DOT> <LENGTH> |
    MethodCall |
    <INTEGER_LITERAL> | // how can this be implemented in node structure (is -N a unary op? )
    <TRUE> | <FALSE> |
    <THIS> |
    <NEW> <INDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN> |
    <BANG> Expression |
    <OPEN_PAREN> Expression <CLOSE_PAREN>
;

ArrayExpression:
	ArrayAccessExpression | ArrayCreateExpression
;

ArrayAccessExpression: 
	 <INDENTIFIER>
    | NumericExpression
; 

ArrayCreateExpression: 
	<NEW> <INT> <OPEN_SQUARE_BRACES> <CLOSE_SQUARE_BRACES>
	//TODO: validate new int[]{1,2,3,4,5}
; 


NumericExpression :
    < INDENTIFIER > <DOT> < IDENTIFIER >
    | <OPEN_PAREN> NumericExpression <CLOSE_PAREN>
;

MethodCall:
    MethodCall <DOT> < IDENTIFIER > <OPEN_PAREN> ( Expression (<COMMA> Expression)* )? <CLOSE_PAREN>
    | <THIS>
    | < IDENTIFIER >
;

And:
    LessThan (<LOGIC_AND> LessThan)*
;

LessThan:
    AdditiveExpression (<LESS_THAN> AdditiveExpression)*
;

AdditiveExpression:
    MultiplicativeExpression
	(
		< PLUS > MultiplicativeExpression |
		< MINUS > MultiplicativeExpression
	)*
;

MultiplicativeExpression:
    Not
    (
        < TIMES > Not  |
        < DIVIDE > Not
    )*
;

Not:
    (<BANG>)? Factor | (<BANG>)? Expression
;


Factor: 
	< IDENTIFIER > | <INTEGER_LITERAL>
;