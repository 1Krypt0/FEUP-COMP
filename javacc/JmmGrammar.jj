PARSER_PACKAGE=pt.up.fe.comp;
PARSER_CLASS=JmmGrammarParser;
SMART_NODE_CREATION=false;

SKIP : " " | "\t" | "\r" | "\n";

TOKEN :
	< PLUS : "+" > |
	< MINUS : "-" > |
	< TIMES : "*" > |
	< DIVIDE : "/" > |
	< ASSIGN : "=" > |
	< LESS_THAN : "<" > |
	< LOGIC_AND : "&&" > |
	< OPEN_PAREN : "(" > |
	< CLOSE_PAREN : ")" > |
	< OPEN_SQUARE_BRACES : "[" > |
	< CLOSE_SQUARE_BRACES : "]" > |
	< OPEN_CURLY_BRACES : "{" > |
	< CLOSE_CURLY_BRACES : "}" > |
	< SEMI_COLON : ";" > |

	< INLINE_COMMENT: "//" > | 
	< BANG : "!" > | 

	< IDENTIFIER : ["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "_", "0"-"9"])* > | //TODO: complete
	< INTEGER_LITERAL : (["0" - "9"])+ > |
	
	< IF : "if" > |
	< ELSE : "else" > |
	< WHILE : "while" > |
	< TRUE : "true" > |
	< FALSE: "false" > |
    < DOT : "." > |	
	< CLASS : "class" > |
	< PUBLIC : "public" > |
	< STATIC : "static" > |
	< IMPORT : "import" > |
	< STRING : "String" > |
	< MAIN : "main" > |
	< VOID : "void" > |
	< EXTENDS : "extends" > |
	< LENGTH : "length"> |
	< COMMA : ","> |
	< NEW : "new" > |
	< THIS : "this" > |
	< INT : "int" > |
	< RETURN : "return" > |
	< BOOLEAN : "boolean" >    
;

//SPECIAL_TOKEN: 
//	<INLINE_COMMENT> (~["\n","\r"])* ("\n"|"\r"|"\r\n") 
//; 


Program : ImportDeclaration ClassDeclaration <EOF> ;

ImportDeclaration : (< IMPORT > < IDENTIFIER > (< DOT > < IDENTIFIER >)* < SEMI_COLON >)* ;

ClassDeclaration : < CLASS > < IDENTIFIER >  ( < EXTENDS > < IDENTIFIER >)? < OPEN_CURLY_BRACES >
                    (VarDeclaration)* (MethodDeclaration)*
                    < CLOSE_CURLY_BRACES > ;

VarDeclaration : Type <INDENTIFIER> < SEMI_COLON > ;


MethodDeclaration : < PUBLIC > (MainDeclaration | NormalMethodDeclaration) ;

MainDeclaration : < STATIC > < VOID > < MAIN > <OPEN_PAREN > < STRING > < OPEN_SQUARE_BRACES > < CLOSE_SQUARE_BRACES >
                    < IDENTIFIER > < CLOSE_PAREN > < OPEN_CURLY_BRACES > MethodBody < CLOSE_CURLY_BRACES > ;


NormalMethodDeclaration : Type < IDENTIFIER > < OPEN_PAREN >
                    (ParameterDeclaration ( < COMMA > ParameterDeclaration)*)? < CLOSE_PAREN > < OPEN_CURLY_BRACES >
                    MethodBody < RETURN > Expression <SEMI_COLON > < CLOSE_CURLY_BRACES > ;

MethodBody: (VarDeclaration)* (Statement)* ;


ParameterDeclaration : Type <IDENTIFIER> ;

Type : <INT> (<OPEN_SQUARE_BRACES> <CLOSE_SQUARE_BRACES>)? | <BOOLEAN> | <IDENTIFIER> ;

Statement:
    <OPEN_CURLY_BRACES> (Statement)* <CLOSE_CURLY_BRACES>
    | <WHILE> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement
    | Expression <SEMI_COLON>
    | <INDENTIFIER> <ASSIGN> Expression <SEMI_COLON>
    | <INDENTIFIER> <OPEN_SQUARE_BRACES> Expression <CLOSE_SQUARE_BRACES> <ASSIGN> Expression <SEMICOLON> ;

IfStatement: <IF> <OPEN_PAREN> Expression <CLOSE_PAREN> Statement <ELSE> Statement ;

WhileStatement: <WHILE> <OPEN_PAREN> ExpressionAnd <CLOSE_PAREN> Statement;

ExpressionAnd : ExpressionLessThan (<AND> ExpressionLessThan)* ;

ExpressionLessThan: (ExpressionAdd | ExpressionSub) ( <LESS> (ExpressionAdd | ExpressionSub) )* ;

ExpressionAdd: (ExpressionMul | ExpressionDiv) (<PLUS> (ExpressionMul | ExpressionDiv))* ;

ExpressionSub: (ExpressionMul | ExpressionDiv) (<MINUS> (ExpressionMul | ExpressionDiv))* ;

ExpressionMul: ExpressionArray (<TIMES> ExpressionArray)* ;

ExpressionDiv:  ExpressionArray (<DIVIDE> ExpressionArray)* ;

ExpressionArray: ExpressionNot (Array)? ;

Array: <OPEN_SQUARE_BRACES> ExpressionAnd <CLOSE_SQUARE_BRACES> ;

ExpressionNot: ExpressionDot | (<BANG> ExpressionNot)

ExpressionDot: Expression (<DOT> (<LENGTH> | MethodCall))* ;

MethodCall: <IDENTIFIER> <OPEN_PAREN> Params <CLOSE_PAREN> ;

Params: ExpressionAnd (<COLON> ExpressionAnd)* ;

Expression:
    <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE>
    | <THIS>
    | <IDENTIFIER>
    | <OPEN_PAREN> ExpressionAnd <CLOSE_PAREN> ;
    | <NEW> (<INT> Array | <IDENTIFIER> <OPEN_PAREN> <CLOSE_PAREN) ;
